from django.shortcuts import render, redirect

from django.http import HttpResponse

from . models import Project, Tag, Riview

#now indorder to use a model form that we jsut created in the forms.py we are just gonna import it into our views.py
from .forms import ProjectForm, RiviewForm

#restrict unauthenticated user from seeing add project page
#we won't be using mixins here because we are using function based views mixins are used when using class based views when foloowing standard procedures for django web development
#instead we will be using login_required decorator to ristrict unauthenticated users from acessing certain pages in our website
from django.contrib.auth.decorators import login_required

#import searchProject.py file here so that we can search projects in the projects_list.html page
from . searchProject import searchProject

#import project_list_pagination.py
from . projects_list_pagination import paginate_projects_list

#import he flash messages to let the users know that riview is submitted
from django.contrib import messages

# Create your views here.

def projects(request):
    projects , search_query = searchProject(request) #search projects (query set)

    #here call the paginate_projects_list() function from projects_list_pagination.py file to implement pagination in single-project.html page
    custom_range, projects = paginate_projects_list(request, projects, 6)

    data_for_front_end = {
        'projects' : projects,
        'search_query':search_query,
        'custom_range':custom_range
    }
    return render(request, 'projects/projects_list.html', data_for_front_end)

def project(request, pk):
    projectObj = Project.objects.get(id=pk)
    form = RiviewForm()

    #process the riview model form
    if request.method == 'POST':
        form = RiviewForm(request.POST) #get the riview from the front end
        riview = form.save(commit=False) #get the instance of that riview
        riview.project = projectObj # set the project to the riview
        riview.owner = request.user.profile #set the owner of the riview
        riview.save() #now save the riview
        #update project vote count
        projectObj.getVoteCount
        messages.success(request,'Riview Submitted')
        return redirect('project', pk=projectObj.id)

    tags = projectObj.tags.all()
    data_for_front_end = {
        'projectObj':projectObj,
        'tags':tags,
        'form':form,
    }
    return render(request, 'projects/single-project.html', data_for_front_end)

#resitrict unauthenticated users from acessing add project page in our website
#@login_required(login_url='pass the url to redirect unauthenticated user to the login page')
#this view function will create a model form for us for creating a project in the project app in django
@login_required(login_url='login')
def createProject(request):
    #here we will connect the newly created project to its authenticated(logged in user) user who actually created it using create-project link in the Add project button in their respective user accounts
    #so by doing this every project will have an owner in this case it will be the logged in or authenticated user in current time
    profile = request.user.profile  #get the logged in user

    # here we will create a form that will be generated by the model form in the forms.py file by the class ProjectForm...
    form = ProjectForm()

    if request.method == 'POST':
        #hendle tags :- users should be able to add their own tags to the project
        newTags = request.POST.get('newtags').replace("," , " ").split() #split is gonna take each individual word in the string and split it into different strings of lists

        #for debugging
        print(request.POST)
        form = ProjectForm(request.POST, request.FILES) #request.FILES will get the images uploaded by the users from the front end and now the links of those images can be saved in the database
        if form.is_valid(): #save the form data if the form is valid and it will add the newly created object to the database
            project = form.save(commit=False) #it is gonna give us the instance of the current project

            #here we are setting the currently logged in user to this newly created project as an owner of that particular project
            project.owner = profile #and then we can go into that project instance and update the owner attribute of that newly created project owner is the oneToMany relationship
            project.save() #now finally re save the newly created project into our database

            for tag in newTags:
                #now create tags while making sure there are no duplicates in the database
                tag, created = Tag.objects.get_or_create(name = tag) #if the tag is not already prsent then create a tag if the tag is already present then query the tag
                #get the project here with many to many relationships
                project.tags.add(tag) #now set the tags to the project

            return redirect('account')

    data_for_front_end = {
         'form':form,
    }
    return render(request, "projects/project_form.html", data_for_front_end)

#create an update view and here we are gonna reuse the model form from form.py file that we created inside our projects application in our django project
@login_required(login_url='login')
#if a user1 is logged in as a user and if that user1 knows the id of the project of user2 then he could just copy paste the link of that user2's project
#and edit the project him self and we need to stop that from happening
def updateProject(request, pk):
    #prevent user1 from acessing user2's projects via url route link (unique project link) in edit projects page
    profile = request.user.profile

    #profile.project_set is gonna return only the set of projects that the logged in user owns
    #now if a user1 tries to visit a url route that leads him to a project owned by user2 in the edit projects page then
    #project = profile.project_set.get(id=pk) is gonna prevent user1 from going to that route
    project = profile.project_set.get(id=pk) #here we are gonna get the project from the database that has the id matching to the primary key that is passed from the front end
    # here we will create a form that will be generated by the model form in the forms.py file by the class ProjectForm
    form = ProjectForm(instance = project) #the only difference between createView and updateView is we are gonna pass in an instance
                         #so an instance is gonna be the project that we are gonna edit

    if request.method == 'POST':
        #hendle tags :- users should be able to add their own tags to the project
        newTags = request.POST.get('newtags').replace("," , " ").split() #split is gonna take each individual word in the string and split it into different strings of lists


        #for debugging
        print(request.POST)
        form = ProjectForm(request.POST , request.FILES , instance = project) # here pass request.POST along with what project are we updating at the moment instance = project
        if form.is_valid(): #save the form data if the form is valid and it will add the newly created object to the database
            project = form.save()
            for tag in newTags:
                #now create tags while making sure there are no duplicates in the database
                tag, created = Tag.objects.get_or_create(name = tag) #if the tag is not already prsent then create a tag if the tag is already present then query the tag
                #get the project here with many to many relationships
                project.tags.add(tag) #now set the tags to the project

            return redirect('account')

    data_for_front_end = {
         'form':form,
         'project':project,
    }
    return render(request, "projects/project_form.html", data_for_front_end)

#create a function for deleting a project in the projects application of this django project
#if a user1 is logged in as a user and if that user1 knows the id of the project of user2 then he could just copy paste the link of that user2's project
#and delete the project him self and we need to stop that from happening
@login_required(login_url='login')
def deleteProject(request, pk):
    #prevent user1 from acessing user2's projects via url route link (unique project link) in delete projects page
    profile = request.user.profile
    #profile.project_set is gonna return only the set of projects that the logged in user owns
    #now if a user1 tries to visit a url route that leads him to a project owned by user2 in the delete projects page then
    #project = profile.project_set.get(id=pk) is gonna prevent user1 from going to that route
    project = profile.project_set.get(id=pk)

    if request.method == 'POST':
        project.delete() #delete the project from the database
        return redirect('account')
    data_for_front_end ={
        'object':project,
    }
    return render(request, "delete_template.html", data_for_front_end)
